class Solution {
    /*
    Start from the last character and move backward.
    At each position (i, j), check:
    If s1[i] == s3[i+j] → Can we form s3 by moving in s1?
    If s2[j] == s3[i+j] → Can we form s3 by moving in s2?
    If either condition holds, mark dp[i][j] = true.
    */
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length();
        int n = s2.length();
        if (m + n != s3.length()) {
            return false;
        }
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[m][n] = true;
        
        for (int i = m; i >= 0; i--) {
            for (int j = n; j >= 0; j--) {
                if (i < m && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j]) {
                    dp[i][j] = true;
                }
                if (j < n && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1]) {
                    dp[i][j] = true;
                }
            }
        }
        return dp[0][0];
    }
}
-----
Subarray Sums Divisible by K
Input: nums = [4,5,0,-2,-3,1], k = 5
Output: 7
Explanation: There are 7 subarrays with a sum divisible by k = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]

public int subarraysDivByK(int[] nums, int k) {
    HashMap<Integer, Integer> prefixMap = new HashMap<>();
    prefixMap.put(0, 1);
    int sum = 0, ans = 0;
    for(int i = 0; i < nums.length; i++) {
        sum = (sum + nums[i]) % k;
        if(sum < 0) sum += k;
        if(prefixMap.containsKey(sum)) {
            ans += prefixMap.get(sum);
        }
        prefixMap.put(sum, prefixMap.getOrDefault(sum, 0) + 1);
    }
    return ans;
}
-------
Given an array of integers, return the length of the longest subarray where the sum is divisible by K.
public int subarraysDivByK(int[] nums, int k) {
    HashMap<Integer, Integer> prefixMap = new HashMap<>();
    prefixMap.put(0, -1); // remainder 0 at index -1
    int sum = 0, ans = 0;
    for (int i = 0; i < nums.length; i++) {
        sum = (sum + nums[i]) % k;
        if (sum < 0) sum += k;
        if (prefixMap.containsKey(sum)) {
            ans = Math.max(ans, i - prefixMap.get(sum));
        } else {
            prefixMap.put(sum, i); // store first occurrence
        }
    }
    return ans;
}
