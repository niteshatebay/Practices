class Solution {
    /*
    Start from the last character and move backward.
    At each position (i, j), check:
    If s1[i] == s3[i+j] → Can we form s3 by moving in s1?
    If s2[j] == s3[i+j] → Can we form s3 by moving in s2?
    If either condition holds, mark dp[i][j] = true.
    */
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length();
        int n = s2.length();
        if (m + n != s3.length()) {
            return false;
        }
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[m][n] = true;
        
        for (int i = m; i >= 0; i--) {
            for (int j = n; j >= 0; j--) {
                if (i < m && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j]) {
                    dp[i][j] = true;
                }
                if (j < n && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1]) {
                    dp[i][j] = true;
                }
            }
        }
        return dp[0][0];
    }
}

-----

public int candy(int[] nums) {
  int n = nums.length;
  int sum = 1, i = 1;
  while (i < n) {
      if (nums[i] == nums[i - 1]) {
          sum++;
          i++;
          continue;
      }
      int peak = 1;
      while (i < n && nums[i] > nums[i - 1]) {
          peak++;
          sum += peak;
          i++;
      }
      int down = 0;
      while (i < n && nums[i] < nums[i - 1]) {
          down++;
          sum += down;
          i++;
      }
      down++;
      if (down > peak) {
          sum += (down - peak);
      }
  }
  return sum;
}

-----

class Solution {
    public int sumSubarrayMins(int[] arr) {
        int sum = 0, n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] left = new int[n];
        int[] right = new int[n];

        // Calculate the index of the previous element smaller than the current element to the left
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && arr[i] < arr[stack.peek()]) {
                stack.pop();
            }
            left[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }
        stack.clear();
        
        // Calculate the index of the previous element smaller than the current element to the right
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && arr[i] <= arr[stack.peek()]) {
                stack.pop();
            }
            right[i] = stack.isEmpty() ? n : stack.peek();
            stack.push(i);
        }
        
        //multiplies the number there with the distances to its left and right smaller neighbors
        for (int i = 0; i < n; i++) {
            sum += arr[i] * (i - left[i]) * (right[i] - i);
        }

        return sum;
    }
}
